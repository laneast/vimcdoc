<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM 中文帮助: 使用 Vim9 脚本类</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
<link rel="canonical" href="https://yianwillis.github.io/vimcdoc/doc/vim9class.html" />
<script type="text/javascript" src="vimcdoc.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
<nav id=banner>
<form action=tags.html target="tag_iframe">
  <input type="text" name="tag" id="tag" placeholder="标签搜索">
</form>
<iframe name="tag_iframe" src=""></iframe>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a> &middot;
</nav>

<header>
<h2>vim9class</h2>
</header>
<article id=outer>
<section class=inner>
<b class="vimtag"> <a name="vim9class.txt">vim9class.txt</a> </b> 适用于 Vim 9.0 版本。   最近更新: 2025年3月


                  <code class="vim">VIM 参考手册    by Bram Moolenaar</code>
                                <code class="vim">译者</code>: Willis


<code class="note">备注</code> - 本文档未完成，一切都可能会变动！ - <code class="note">备注</code>


Vim9 类、对象、界面、类型和枚举。

1.  总览                         <a href="vim9class.html#Vim9-class-overview">Vim9-class-overview</a> 
2.  简单类                       <a href="vim9class.html#Vim9-simple-class">Vim9-simple-class</a> 
3.  类变量及方法                 <a href="vim9class.html#Vim9-class-member">Vim9-class-member</a> 
4.  使用抽象类                   <a href="vim9class.html#Vim9-abstract-class">Vim9-abstract-class</a> 
5.  使用抽象界面                 <a href="vim9class.html#Vim9-using-interface">Vim9-using-interface</a> 
6.  更多类的细节                 <a href="vim9class.html#Vim9-class">Vim9-class</a> 
7.  类型定义                     <a href="vim9class.html#Vim9-type">Vim9-type</a> 
8.  枚举                         <a href="vim9class.html#Vim9-enum">Vim9-enum</a> 

9.  理据
10. 以后再做

</section><hr class="doubleline" /><section class=inner>
<h4></h4>1. 总览                                         <b class="vimtag"> <a name="Vim9-class-overview">Vim9-class-overview</a> </b>

时髦的叫法叫 "面向对象编程"。这个主题有大量的学习材料。本文档假定你已了解相关
基本概念，着重说明  <a href="vim9.html#Vim9">Vim9</a>  脚本提供的功能。还有一些如何有效使用这些功能有用的提
示。

最基本的项目是对象:
- 对象保存状态。它包含一或多个变量，每个变量可带值。
- 对象提供函数，用于访问和操作状态。这些函数在 "对象上" 调用，这和传统的分离数
  据以及操作数据的代码的方式有所区隔。
- 对象有定义良好的界面，包括有类型的成员变量和方法。
- 对象由类创建，所有这样的对象有相同的界面。运行时不能改变，界面并非动态。

对象只能由类创建。类提供了:
- new() 方法，构造函数，返回属于该类的一个对象。此方法在类名上调用:
  MyClass.new()。
- 所有该类的对象共享的状态: 类变量 (类成员)。
- 类的层次结构，即超类和子类，继承。

界面用于指定对象的属性:
- 对象可声明多个它实现的界面。
- 可以相同方式调用实现相同界面的不同对象。

类的层次结构支持单一继承。其它的需要可用界面实现。


<code class="section">类模型 </code>

可以任何方式构造类的模型。留心你要做什么，不要试图为现实世界建模。这有点混淆，
尤其老师在课堂上会用现实事物来解释类关系，你可能会因此认为你的模型应反映现实世
界。不需要！模型应匹配你的目的。

要记得组合 (一个对象包含另一对象) 常常优于继承 (一个对象扩展另一对象)。不要浪
费时间去找最优的类模型。或者浪费时间讨论到底正方形是一种矩形还是矩形是一种正方
形。这无关紧要。


</section><hr class="doubleline" /><section class=inner>
<h4></h4>2.  简单类                                      <b class="vimtag"> <a name="Vim9-simple-class">Vim9-simple-class</a> </b>

从简单的例子开始: 保存文本位置的类 (更有效的做法稍后会讲): 
<code class="example"></code>
<code class="example">        class TextPosition</code>
<code class="example">           this.lnum: number</code>
<code class="example">           this.col: number</code>
<code class="example"></code>
<code class="example">           def new(lnum: number, col: number)</code>
<code class="example">              this.lnum = lnum</code>
<code class="example">              this.col = col</code>
<code class="example">           enddef</code>
<code class="example"></code>
<code class="example">           def SetLnum(lnum: number)</code>
<code class="example">              this.lnum = lnum</code>
<code class="example">           enddef</code>
<code class="example"></code>
<code class="example">           def SetCol(col: number)</code>
<code class="example">              this.col = col</code>
<code class="example">           enddef</code>
<code class="example"></code>
<code class="example">           def SetPosition(lnum: number, col: number)</code>
<code class="example">              this.lnum = lnum</code>
<code class="example">              this.col = col</code>
<code class="example">           enddef</code>
<code class="example">         endclass</code>
                                                        <b class="vimtag"> <a name="object">object</a> </b> <b class="vimtag"> <a name="Object">Object</a> </b>
new() 方法创建此类的一个对象: 
<code class="example"></code>
<code class="example">        var pos = TextPosition.new(1, 1)</code>
<code class="example"></code>
可直接访问对象变量 "lnum" 和 "col": 
<code class="example"></code>
<code class="example">        echo $'文本位置为 ({pos.lnum}, {pos.col})'</code>
                                                        <b class="vimtag"> <a name="E1317">E1317</a> </b> <b class="vimtag"> <a name="E1327">E1327</a> </b>
如果你有使用其它面向对象语言的经验，肯定会<code class="note">注意</code>到 Vim 里对象成员引用时总是用
"this." 前缀。这和 Java 和 TypeScript 这些语言不同。此命名惯例容易找到对象成
员。相反地，不带 "this." 前缀的变量就是非对象变量。


<code class="section">对象变量写访问 </code>

现在试试直接修改对象变量: 
<code class="example"></code>
<code class="example">        pos.lnum = 9</code>
                                                        <b class="vimtag"> <a name="E1335">E1335</a> </b>
这会报错！这是因为缺省对象变量可以读但不可写。所以 TextPosition 类要为此提供一
个方法: 
<code class="example"></code>
<code class="example">        pos.SetLnum(9)</code>
<code class="example"></code>
对象变量可读但不可写是最常见和安全的方法。通常读值没有问题，但设置值时会有副作
用，需要特别处理。此例中，SetLnum() 方法可以检查行号是否合法，不然可以报错或者
选择最接近的合法值。
                                                        <b class="vimtag"> <a name=":public">:public</a> </b> <b class="vimtag"> <a name="E1331">E1331</a> </b>
如果你不担心副作用而想随时修改对象变量，可标记其为 public: 
<code class="example"></code>
<code class="example">        public this.lnum: number</code>
<code class="example">        public this.col: number</code>
<code class="example"></code>
现在你就不需要 SetLnum()、SetCol() 和 SetPosition() 方法了，直接设置
"pos.lnum" 不再报错。
                                                        <b class="vimtag"> <a name="E1326">E1326</a> </b>
试图设置尚不存在的对象变量会报错: 
<code class="example">        pos.other = 9</code>
<code class="section">        E1326: Member not found on object "TextPosition": other </code>

                                                        <b class="vimtag"> <a name="E1376">E1376</a> </b>
不能使用类名来访问对象变量。

<code class="section">私有变量 </code>
                                        <b class="vimtag"> <a name="private-variable">private-variable</a> </b> <b class="vimtag"> <a name="E1332">E1332</a> </b> <b class="vimtag"> <a name="E1333">E1333</a> </b>
另一方面，如果不想让对象变量直接可读，可标记其为私有。这是通过给名字加上下划线
前缀完成的: 
<code class="example"></code>
<code class="example">        this._lnum: number</code>
<code class="example">        this._col number</code>
<code class="example"></code>
你现在需要提供读取私有变量值的方法。常称为 getter。推荐使用 "Get" 开头: 
<code class="example"></code>
<code class="example">        def GetLnum(): number</code>
<code class="example">           return this._lnum</code>
<code class="example">        enddef</code>
<code class="example"></code>
<code class="example">        def GetCol() number</code>
<code class="example">           return this._col</code>
<code class="example">        enddef</code>
<code class="example"></code>
此例不甚有用，还不如干脆声明变量为公共。但如果可以对值进行检查，就会有用些。例
如，限制行号不超过总行数: 
<code class="example"></code>
<code class="example">        def GetLnum(): number</code>
<code class="example">           if this._lnum &gt; this._lineCount</code>
<code class="example">              return this._lineCount</code>
<code class="example">           endif</code>
<code class="example">           return this._lnum</code>
<code class="example">        enddef</code>
<code class="example"></code>
<code class="section">私有方法 </code>
                                                <b class="vimtag"> <a name="private-method">private-method</a> </b> <b class="vimtag"> <a name="E1366">E1366</a> </b>
要使得对象方法只能被同类的其他方法访问，而在类外不可见，可标记其为私有。这是通
过给方法名字加上下划线前缀完成的: 
<code class="example"></code>
<code class="example">    class SomeClass</code>
<code class="example">        def _Foo(): number</code>
<code class="example">          return 10</code>
<code class="example">        enddef</code>
<code class="example">        def Bar(): number</code>
<code class="example">          return this._Foo()</code>
<code class="example">        enddef</code>
<code class="example">    endclass</code>

在类的外部访问私有方法会报错 (接上例的类定义): 
<code class="example"></code>
<code class="example">    var a = SomeClass.new()</code>
<code class="example">    a._Foo()</code>

<code class="section">简化 new() 方法 </code>
                                                <b class="vimtag"> <a name="new()">new()</a> </b> <b class="vimtag"> <a name="constructor">constructor</a> </b>
许多构造函数接受对象变量的值作为参数。常常会见到以下模式: 
<code class="example"></code>
<code class="example">         class SomeClass</code>
<code class="example">           this.lnum: number</code>
<code class="example">           this.col: number</code>
<code class="example"></code>
<code class="example">           def new(lnum: number, col: number)</code>
<code class="example">              this.lnum = lnum</code>
<code class="example">              this.col = col</code>
<code class="example">           enddef</code>
<code class="example">         endclass</code>

                                                        <b class="vimtag"> <a name="E1390">E1390</a> </b>
这不但要写大段代码，还要重复提供每个变量的类型。因为这种模式很常见，系统提供了
以下编写 new() 的快捷方式: 
<code class="example"></code>
<code class="example">           def new(this.lnum, this.col)</code>
<code class="example">           enddef</code>
<code class="example"></code>
这里的语义很容易理解: 以带 "this." 的对象变量名作为 new() 参数，意味着调用
new() 时提供的值赋值到该对象变量。此机制来自于 Dart 语言。

组合使用这种使用 new() 的方法和标记公共变量，会得到和最初例子等价但简短得多的
类定义: 
<code class="example"></code>
<code class="example">        class TextPosition</code>
<code class="example">           public this.lnum: number</code>
<code class="example">           public this.col: number</code>
<code class="example"></code>
<code class="example">           def new(this.lnum, this.col)</code>
<code class="example">           enddef</code>
<code class="example"></code>
<code class="example">           def SetPosition(lnum: number, col: number)</code>
<code class="example">              this.lnum = lnum</code>
<code class="example">              this.col = col</code>
<code class="example">           enddef</code>
<code class="example">         endclass</code>
<code class="example"></code>
构造新对象的顺序是:
1. 分配内存，并清零内存。所有值初始为零/假值/空值。
2. 为每个声明时带初始器的的对象变量进行表达式计算并赋值。按照变量在类中定义的
   顺序依次进行。
3. 对使用 "this.name" 形式的 new() 方法的参数进行赋值。
4. 执行 new() 方法的本体。

如果类扩展了某父类，进行同样的操作。在第二步中先初始父类的对象变量。无需为父类
调用 "super()" 或 "new()"。

                                                        <b class="vimtag"> <a name="E1365">E1365</a> </b>
new() 方法的定义不能指定返回类型。它总是返回类的一个对象。

                                                        <b class="vimtag"> <a name="E1386">E1386</a> </b>
调用对象方法时，方法名之前必须是对象变量名。不能使用类名来调用对象方法。

</section><hr class="doubleline" /><section class=inner>
<h4></h4>3.  类变量和方法                                <b class="vimtag"> <a name="Vim9-class-member">Vim9-class-member</a> </b>

                                            <b class="vimtag"> <a name=":static">:static</a> </b> <b class="vimtag"> <a name="E1337">E1337</a> </b> <b class="vimtag"> <a name="E1338">E1338</a> </b> <b class="vimtag"> <a name="E1368">E1368</a> </b>
用 "static" 声明类成员。在类定义的内部，使用这些名字不需前缀: 
<code class="example"></code>
<code class="example">        class OtherThing</code>
<code class="example">           this.size: number</code>
<code class="example">           static totalSize: number</code>
<code class="example"></code>
<code class="example">           def new(this.size)</code>
<code class="example">              totalSize += this.size</code>
<code class="example">           enddef</code>
<code class="example">        endclass</code>
                                                        <b class="vimtag"> <a name="E1340">E1340</a> </b> <b class="vimtag"> <a name="E1341">E1341</a> </b>
因为按本名使用，不允许覆盖方法参数名或局部变量名。

                                            <b class="vimtag"> <a name="E1374">E1374</a> </b> <b class="vimtag"> <a name="E1375">E1375</a> </b> <b class="vimtag"> <a name="E1384">E1384</a> </b> <b class="vimtag"> <a name="E1385">E1385</a> </b>
在类定义之外，类成员的访问必须使用类名作为前缀。不能使用对象来访问类成员。

和对象成员一样，可通过下划线名字前缀来使访问私有，也可用 "public" 前缀来标识
其为公共: 
<code class="example"></code>
<code class="example">    class OtherThing</code>
<code class="example">        static total: number          # 任何人都可读，只有类可写</code>
<code class="example">        static _sum: number           # 只有类可读写</code>
<code class="example">        public static result: number  # 任何人可读写</code>
<code class="example">    endclass</code>

                                                        <b class="vimtag"> <a name="class-method">class-method</a> </b>
也可用 "static" 声明类方法。它们可以使用类变量但不能访问对象变量，不能使用
"this" 关键字。 
<code class="example"></code>
<code class="example">        class OtherThing</code>
<code class="example">           this.size: number</code>
<code class="example">           static totalSize: number</code>
<code class="example"></code>
<code class="example">           # 清除总大小，返回清除之前的值。</code>
<code class="example">           static def ClearTotalSize(): number</code>
<code class="example">              var prev = totalSize</code>
<code class="example">              totalSize = 0</code>
<code class="example">              return prev</code>
<code class="example">           enddef</code>
<code class="example">        endclass</code>
<code class="example"></code>
在类内部，可以直接按名字调用类方法，在类的外部则必须使用类名前缀:
 <code class="badlink">OtherThing.ClearTotalSize()</code> 。要在子类中使用父类的类方法，必须用类名前缀。

和对象方法一样，可用下划线作为方法名首字符使之私有: 
<code class="example"></code>
<code class="example">    class OtherThing</code>
<code class="example">        static def _Foo()</code>
<code class="example">            echo "Foo"</code>
<code class="example">        enddef</code>
<code class="example">        def Bar()</code>
<code class="example">            _Foo()</code>
<code class="example">        enddef</code>
<code class="example">    endclass</code>

                                                        <b class="vimtag"> <a name="E1370">E1370</a> </b>
<code class="note">注意</code> 构造函数不能声明为 "static"，因为它们本来就是。

要在扩展类里访问父类的类方法和类变量，必须使用类名前缀，就像在类的定义之外的其
他一切场合一样: 
<code class="example"></code>
<code class="example">    vim9script</code>
<code class="example">    class Vehicle</code>
<code class="example">        static nextID: number = 1000</code>
<code class="example">        static def GetID(): number</code>
<code class="example">            nextID += 1</code>
<code class="example">            return nextID</code>
<code class="example">        enddef</code>
<code class="example">    endclass</code>
<code class="example">    class Car extends Vehicle</code>
<code class="example">        this.myID: number</code>
<code class="example">        def new()</code>
<code class="example">            this.myID = Vehicle.GetID()</code>
<code class="example">        enddef</code>
<code class="example">    endclass</code>

子类不继承类变量和方法。子类可以声明与父类重名的类变量或方法。此时，根据成员所
在的类使用相应的类成员。子类类成员的类型可与父类的不同。

</section><hr class="doubleline" /><section class=inner>
<h4></h4>4.  使用抽象类                                  <b class="vimtag"> <a name="Vim9-abstract-class">Vim9-abstract-class</a> </b>

抽象类构成了至少一个的子类的基底。类模型常常需要若干类共享相同的属性，但带这些
属性的类缺乏足够的状态以创建对象。子类必须先扩展抽象类，加入缺失的状态和/或方
法，然后才能用于创建对象。

例如，Shape 类可以保存 color 和 thickness。不能直接创建 Shape 对象，因为缺少何
种形状的信息。Shape 类函数构成了 Square 和 Triangle 类的基底，后两者就可以创建
对象了。例如:

<code class="example"></code>
<code class="example">        abstract class Shape</code>
<code class="example">           this.color = Color.Black</code>
<code class="example">           this.thickness = 10</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        class Square extends Shape</code>
<code class="example">           this.size: number</code>
<code class="example"></code>
<code class="example">           def new(this.size)</code>
<code class="example">           enddef</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        class Triangle extends Shape</code>
<code class="example">           this.base: number</code>
<code class="example">           this.height: number</code>
<code class="example"></code>
<code class="example">           def new(this.base, this.height)</code>
<code class="example">           enddef</code>
<code class="example">        endclass</code>

抽象类和普通类的定义方式相同，但不能用 new() 方法。 <b class="vimtag"> <a name="E1359">E1359</a> </b>

                                                <b class="vimtag"> <a name="abstract-method">abstract-method</a> </b> <b class="vimtag"> <a name="E1371">E1371</a> </b> <b class="vimtag"> <a name="E1372">E1372</a> </b>
抽象类中，可在方法定义时用 "abstract" 前缀，来定义抽象方法: 
<code class="example"></code>
<code class="example">        abstract class Shape</code>
<code class="example">           abstract def Draw()</code>
<code class="example">           abstract static def SetColor()</code>
<code class="example">        endclass</code>

                                                <b class="vimtag"> <a name="E1373">E1373</a> </b>
扩展抽象类的类必须实现所有的抽象方法。签名 (参数、参数类型及返回类型) 必需严格
一致。抽象类的类方法也可以是抽象方法。

</section><hr class="doubleline" /><section class=inner>
<h4></h4>5.  使用界面                                    <b class="vimtag"> <a name="Vim9-using-interface">Vim9-using-interface</a> </b>

上面 Shape、Square 和 Triangle 的例子如果提供了计算对象面积的方法会更有用。为
此，我们可以创建 HasSurface 界面，指定一个返回数值的方法 Surface()。本例在上例
基础上进行扩展: 
<code class="example"></code>
<code class="example">        abstract class Shape</code>
<code class="example">           this.color = Color.Black</code>
<code class="example">           this.thickness = 10</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        interface HasSurface</code>
<code class="example">           def Surface(): number</code>
<code class="example">        endinterface</code>
<code class="example"></code>
<code class="example">        class Square extends Shape implements HasSurface</code>
<code class="example">           this.size: number</code>
<code class="example"></code>
<code class="example">           def new(this.size)</code>
<code class="example">           enddef</code>
<code class="example"></code>
<code class="example">           def Surface(): number</code>
<code class="example">              return this.size * this.size</code>
<code class="example">           enddef</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        class Triangle extends Shape implements HasSurface</code>
<code class="example">           this.base: number</code>
<code class="example">           this.height: number</code>
<code class="example"></code>
<code class="example">           def new(this.base, this.height)</code>
<code class="example">           enddef</code>
<code class="example"></code>
<code class="example">           def Surface(): number</code>
<code class="example">              return this.base * this.height / 2</code>
<code class="example">           enddef</code>
<code class="example">        endclass</code>

                                        <b class="vimtag"> <a name="E1348">E1348</a> </b> <b class="vimtag"> <a name="E1349">E1349</a> </b> <b class="vimtag"> <a name="E1367">E1367</a> </b> <b class="vimtag"> <a name="E1382">E1382</a> </b> <b class="vimtag"> <a name="E1383">E1383</a> </b>
如果类声明会实现某界面，类中必须出现该界面的所有项目，且类型相同。

界面名可用做类型: 
<code class="example"></code>
<code class="example">        var shapes: list&lt;HasSurface&gt; = [</code>
<code class="example">                                Square.new(12),</code>
<code class="example">                                Triangle.new(8, 15),</code>
<code class="example">                                ]</code>
<code class="example">        for shape in shapes</code>
<code class="example">           echo $'面积是 {shape.Surface()}'</code>
<code class="example">        endfor</code>

                                        <b class="vimtag"> <a name="E1378">E1378</a> </b> <b class="vimtag"> <a name="E1379">E1379</a> </b> <b class="vimtag"> <a name="E1380">E1380</a> </b> <b class="vimtag"> <a name="E1387">E1387</a> </b>
界面只能包含对象方法和只读的对象变量。界面不能包含可读写和私有的对象变量、私有
对象方法、类变量和类方法。

界面可用 "extends" 扩展另一个界面。子界面继承父界面的所有实例变量和方法。

</section><hr class="doubleline" /><section class=inner>
<h4></h4>6.  更多类的细节                                <b class="vimtag"> <a name="Vim9-class">Vim9-class</a> </b> <b class="vimtag"> <a name="Class">Class</a> </b> <b class="vimtag"> <a name="class">class</a> </b>

<code class="section">定义类 </code>
                                        <b class="vimtag"> <a name=":class">:class</a> </b> <b class="vimtag"> <a name=":endclass">:endclass</a> </b> <b class="vimtag"> <a name=":abstract">:abstract</a> </b>
类定义出现在  <a href="vim9class.html#:class">:class</a>  和  <a href="vim9class.html#:endclass">:endclass</a>  之间。整个类在一个脚本文件中定义。定义之
后不能为类新增内容。

只能在一个  <a href="vim9.html#Vim9">Vim9</a>  脚本文件中定义类。 <b class="vimtag"> <a name="E1316">E1316</a> </b>
不能在函数内部定义类。

一个脚本文件中可以定义多个类。最好只导出一个主类。不过，定义类型、枚举和帮助类
还是常用的。

可有前缀  <a href="vim9class.html#:abstract">:abstract</a>  关键字，也可用  <a href="vim9.html#:export">:export</a> 。这样就有以下组合: 
<code class="example"></code>
<code class="example">        class ClassName</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        export class ClassName</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        abstract class ClassName</code>
<code class="example">        endclass</code>
<code class="example"></code>
<code class="example">        export abstract class ClassName</code>
<code class="example">        endclass</code>

                                                        <b class="vimtag"> <a name="E1314">E1314</a> </b>
类名应使用驼峰式。必须以大写字母开头。这样可以避免和内建类型冲突。
                                                        <b class="vimtag"> <a name="E1315">E1315</a> </b>
类名之后可选若干项目。每种只能出现一次。可以任何顺序出现，但建议以下顺序: 
<code class="example">        extends ClassName</code>
<code class="example">        implements InterfaceName, OtherInterface</code>
<code class="example">        specifies SomeInterface</code>
                                                        <b class="vimtag"> <a name="E1355">E1355</a> </b> <b class="vimtag"> <a name="E1369">E1369</a> </b>
每个变量和函数名只能用一次。不能定义同名但带不同类型参数的方法。不能使用同名的
公有和私有成员变量。父类使用的对象变量名不能被子类重用。


<code class="section">对象变量初始化 </code>
如果在类里没有显式指定变量类型，那么类定义时会将其设为 "any"。此类在实例化对象
时，设置变量的类型。

下列保留字不可用作对象或类变量名: "super"、"this"、"true"、"false"、"null"、
"null_blob"、"null_dict"、"null_function"、"null_list"、"null_partial"、
"null_string"、"null_channel" 和 "null_job"。

<code class="section">类扩展 </code>
                                                        <b class="vimtag"> <a name="extends">extends</a> </b>
类可以扩展其它类。 <b class="vimtag"> <a name="E1352">E1352</a> </b> <b class="vimtag"> <a name="E1353">E1353</a> </b> <b class="vimtag"> <a name="E1354">E1354</a> </b>
基本的想法是在已有的类上加上新的属性。

被扩展类称为 "基类" 或 "超类"。新类称为 "子类"。

基类的对象变量被子类全盘接收。不可覆盖 (和一些其它的语言不同)。

                                                <b class="vimtag"> <a name="E1356">E1356</a> </b> <b class="vimtag"> <a name="E1357">E1357</a> </b> <b class="vimtag"> <a name="E1358">E1358</a> </b>
基类的对象方法可以覆盖。参数数目必须一致。方法的参数类型可以是基类方法参数类型
的逆变 (contra-variant) 类型。方法的返回值类型可以是基类方法返回值类型的协变
(covariant) 类型。可通过 "super." 前缀调用基类提供的方法。

                                                <b class="vimtag"> <a name="E1377">E1377</a> </b>
子类方法的访问域 (public 或 private) 必须与父类的相同。

其它对象方法被子类全盘接收。

类方法，包含 "new" 开始的函数，和对象方法一样可以覆盖。可通过类名 (用于类方法)
前缀或 "super." 前缀调用基类的方法。

和其它语言不同，不需要调用基类的构造函数。事实上，也不可以调用。如果子类需要基
类执行的某种初始化，把相关逻辑放在一个对象方法里，在每个构造函数里调用该方法。

如果基类不提供 new() 方法，会自动创建一个。此方法不被子类接收。子类可以定义自
己的 new() 方法，同样地，如果没有，会自动创建一个。


<code class="section">实现界面的类 </code>
                                        <b class="vimtag"> <a name="implements">implements</a> </b> <b class="vimtag"> <a name="E1346">E1346</a> </b> <b class="vimtag"> <a name="E1347">E1347</a> </b> <b class="vimtag"> <a name="E1389">E1389</a> </b>
类可以实现一个或多个界面。"implements" 关键字只能出现一次 <b class="vimtag"> <a name="E1350">E1350</a> </b> 。
可指定多个界面，以逗号分隔。每个界面名只能出现一次。 <b class="vimtag"> <a name="E1351">E1351</a> </b>


<code class="section">定义界面的类 </code>
                                                        <b class="vimtag"> <a name="specifies">specifies</a> </b>
类可以通过一个命名的界面来声明自己的界面、对象变量和方法。这样就不需要单独指定
界面了，很多语言，尤其是 Java，就是如此。


<code class="section">类中的项目 </code>
                                                <b class="vimtag"> <a name="E1318">E1318</a> </b> <b class="vimtag"> <a name="E1325">E1325</a> </b> <b class="vimtag"> <a name="E1388">E1388</a> </b>
类内部，即  <a href="vim9class.html#:class">:class</a>  和  <a href="vim9class.html#:endclass">:endclass</a>  之间，可出现以下项目:
- 对象变量声明: 
<code class="example">        this._memberName: memberType</code>
<code class="example">        this.memberName: memberType</code>
<code class="example">        public this.memberName: memberType</code>
- 类变量声明: 
<code class="example">        static _privateClassVariableName: memberType</code>
<code class="example">        static readonlyClassVariableName: memberType</code>
<code class="example">        static public readwriteClassVariableName: memberType</code>
- 构造方法: 
<code class="example">        def new(arguments)</code>
<code class="example">        def newName(arguments)</code>
- 类方法: 
<code class="example">        static def SomeMethod(arguments)</code>
<code class="example">        static def _PrivateMethod(arguments)</code>
- 对象方法: 
<code class="example">        def SomeMethod(arguments)</code>
<code class="example">        def _PrivateMethod(arguments)</code>
<code class="example"></code>
对象变量必须指定类型。最好的方法是显式指定 ": <code class="special">{type}</code>"。简单类型也可用初始器，
形如 "= 123"，Vim 可以推定类型为数值。更复杂的类型不要这样做，也不能用于不完整
的类型。如: 
<code class="example">        this.nameList = []</code>
这里指定了列表，但项目类型未知。最好这样: 
<code class="example">        this.nameList: list&lt;string&gt;</code>
这里不需要初始化，列表缺省已为空。
                                                        <b class="vimtag"> <a name="E1330">E1330</a> </b>
有些类型不能使用，如 "void"、"null" 和 "v:none"。


<code class="section">定义界面 </code>
                                                <b class="vimtag"> <a name=":interface">:interface</a> </b> <b class="vimtag"> <a name=":endinterface">:endinterface</a> </b>
界面在  <a href="vim9class.html#:interface">:interface</a>  和  <a href="vim9class.html#:endinterface">:endinterface</a>  间定义。可加上前缀  <a href="vim9.html#:export">:export</a> : 
<code class="example"></code>
<code class="example">        interface InterfaceName</code>
<code class="example">        endinterface</code>
<code class="example"></code>
<code class="example">        export interface InterfaceName</code>
<code class="example">        endinterface</code>
                                                        <b class="vimtag"> <a name="E1344">E1344</a> </b>
界面可声明对象变量，和类一样，但没有初始器。
                                                        <b class="vimtag"> <a name="E1345">E1345</a> </b>
界面可用  <a href="vim9.html#:def">:def</a>  声明方法，包括参数和返回类型，但没有本体，也没有  <a href="vim9.html#:enddef">:enddef</a> 。示
例: 
<code class="example"></code>
<code class="example">        interface HasSurface</code>
<code class="example">           this.size: number</code>
<code class="example">           def Surface(): number</code>
<code class="example">        endinterface</code>
<code class="example"></code>
界面名必须以大写字母开始。 <b class="vimtag"> <a name="E1343">E1343</a> </b>
"Has" 前缀方便判断这是界面名，并提示了它提供的功能。
只能在  <a href="vim9.html#Vim9">Vim9</a>  脚本文件中定义界面。 <b class="vimtag"> <a name="E1342">E1342</a> </b>
界面不能 "implement" 另一个界面，但可以 "extend" 另一个界面。 <b class="vimtag"> <a name="E1381">E1381</a> </b>


<code class="section">null 对象 </code>

变量声明时如果指定对象的类型但没有初始化时，其值为 null。试图使用 null 对象时，
Vim 经常不知道应该使用哪个类。因而，Vim 无法检查变量名是否正确，从而给出
"Using a null object" 错误，即使变量名是非法的。 <b class="vimtag"> <a name="E1360">E1360</a> </b> <b class="vimtag"> <a name="E1362">E1362</a> </b> <b class="vimtag"> <a name="E1363">E1363</a> </b>


<code class="section">缺省构造函数 </code>
                                                        <b class="vimtag"> <a name="default-constructor">default-constructor</a> </b>
如果定义类时未提供 new() 方法，会自动生成一个。此缺省构造函数会为每个对象变量
按照它们出现的顺序分别提供一个参数。如你的类是这样: 
<code class="example"></code>
<code class="example">        class AutoNew</code>
<code class="example">           this.name: string</code>
<code class="example">           this.age: number</code>
<code class="example">           this.gender: Gender</code>
<code class="example">        endclass</code>
<code class="example"></code>
那么缺省构造函数就会是: 
<code class="example"></code>
<code class="example">        def new(this.name = v:none, this.age = v:none, this.gender = v:none)</code>
<code class="example">        enddef</code>
<code class="example"></code>
缺省值 "= v:none" 使参数可选。所以，也可不带任何参数地调用  <a href="vim9class.html#new()">new()</a> 。不赋值而使
用对象变量的缺省值。下面是更有用的带缺省值的例子: 
<code class="example"></code>
<code class="example">        class TextPosition</code>
<code class="example">           this.lnum: number = 1</code>
<code class="example">           this.col: number = 1</code>
<code class="example">        endclass</code>
<code class="example"></code>
如果构造函数要强制提供参数，必须自己编写。例如，要上面的 AutoNew 类必须提供
name，可这样定义构造函数: 
<code class="example"></code>
<code class="example">        def new(this.name, this.age = v:none, this.gender = v:none)</code>
<code class="example">        enddef</code>
                                                        <b class="vimtag"> <a name="E1328">E1328</a> </b>
<code class="note">注意</code> 除了这里的 "v:none" 之外，不能使用其它缺省值。要初始化对象变量，在其声明
的地方提供初始值。这样你只须在一个地方寻找缺省值。

缺省构造函数中使用所有的对象变量，包括私有访问的那些。

如果类扩展其它类，被扩展类的对象变量会先出现。


<code class="section">多个构造函数 </code>

通常每个类只有一个 new() 构造函数。如果常常需要传递相同的参数，可简化代码，把
这些参数放到另一个构造函数里。例如，如果经常使用黑色: 
<code class="example"></code>
<code class="example">        def new(this.garment, this.color, this.size)</code>
<code class="example">        enddef</code>
<code class="example">        ...</code>
<code class="example">        var pants = new(Garment.pants, Color.black, "XL")</code>
<code class="example">        var shirt = new(Garment.shirt, Color.black, "XL")</code>
<code class="example">        var shoes = new(Garment.shoes, Color.black, "45")</code>
<code class="example"></code>
要避免每次重复相同的颜色，可加入另一构造函数，包含此颜色: 
<code class="example"></code>
<code class="example">        def newBlack(this.garment, this.size)</code>
<code class="example">           this.color = Color.black</code>
<code class="example">        enddef</code>
<code class="example">        ...</code>
<code class="example">        var pants = newBlack(Garment.pants, "XL")</code>
<code class="example">        var shirt = newBlack(Garment.shirt, "XL")</code>
<code class="example">        var shoes = newBlack(Garment.shoes, "9.5")</code>
<code class="example"></code>
<code class="note">注意</code> 此方法名必须以 "new" 开始。如果没有叫 "new()" 的方法，会加入缺省构造函
数，即使有其它的构造函数也是如此。


</section><hr class="doubleline" /><section class=inner>
<h4></h4>7.  类型定义                                    <b class="vimtag"> <a name="Vim9-type">Vim9-type</a> </b> <b class="vimtag"> <a name=":type">:type</a> </b>

类型定义为类型规格给定名称。例如: 
<code class="example"></code>
<code class="example">        :type ListOfStrings list&lt;string&gt;</code>
<code class="example"></code>
TODO: 更多说明


</section><hr class="doubleline" /><section class=inner>
<h4></h4>8.  枚举                                        <b class="vimtag"> <a name="Vim9-enum">Vim9-enum</a> </b> <b class="vimtag"> <a name=":enum">:enum</a> </b> <b class="vimtag"> <a name=":endenum">:endenum</a> </b>

枚举是从给定值列表中选取一个的类型。示例: 
<code class="example"></code>
<code class="example">        :enum Color</code>
<code class="example">                White</code>
<code class="example">                Red</code>
<code class="example">                Green</code>
<code class="example">                Blue</code>
<code class="example">                Black</code>
<code class="example">        :endenum</code>
<code class="example"></code>
TODO: 更多说明


</section><hr class="doubleline" /><section class=inner>
<h4></h4>9.  理据

 <a href="vim9.html#Vim9">Vim9</a>  类的绝大多数选择来自流行和新开发的语言，如 Java、TypeScript 和 Dart。语
法按照 Vim 脚本的工作方式进行了调整，如使用  <code class="badlink">endclass</code>  而不是用花括号包围整个
类。

面向对象语言的很多常用构造是多年前此类型的编程方法尚在幼年时形成的，后来发现并
非理想。但这些构造已广为使用，无法再改变。而 Vim 完全有做出不同选择的自由，因
为类是全新的功能。和 "老" 语言相较，我们可以使语法更简单也更统一。变化不宜太
大，跟你熟悉的已有语言仍然要大体相像。

一些近期开发的语言加入了很多花哨的功能，我们 Vim 不需要。但有些好的想法我们也
想采用。这样，我们最终的选择以常用语言的共同语法为基底，删除不好的功能，加入新
的容易理解且相当不错的功能。

我们做决定的主要原则是:
- 尽量简单。
- 没有惊奇，和其它语言做的大体相同。
- 避免过去的错误。
- 脚本作者不需要查询帮助就可以理解如何工作，绝大多数语法应一目了然。
- 保持统一。
- 服务目标是一般大小的插件，而不是巨型项目。


<code class="section">构造函数使用 new() </code>

许多语言的构造函数使用类名。缺点是此名字常常很长。而且类改名时构造函数也要跟着
改名。不是大问题，但总是个缺点。

其它语言，如 TypeScript，使用特定名字，如 "constructor()"，这会好一些。不过使
用 "new" 或 "new()" 来创建新对象和 "constructor()" 好象关系不大。

对  <a href="vim9.html#Vim9">Vim9</a>  脚本而言，为所有的构造函数使用相同的方法名看来是正确的选择，而叫它
new() 使调用者和被调用的方法之间的关系非常明确。


<code class="section">构造函数不能重载 </code>

Vim 脚本里，不管是老式还是  <a href="vim9.html#Vim9">Vim9</a>  脚本，方法不能重载。这意味着不能有相同的方法
名但带不同类型的参数。因此，只能有一个 new() 构造函数。

 <a href="vim9.html#Vim9">Vim9</a>  脚本使重载成为可能，因为参数有类型。但这很快变得复杂。看到 new() 调用
时，要先检查参数的类型，以确定多个 new() 方法里实际要调用哪个。而这需要检视相
当多的代码。如其中一个参数是方法的返回值，那么就要先找到该方法，来查看它返回什
么类型。

相反地，每个构造函数必须有以 "new" 开始的不同名字。这样就可以有带不同参数的多
个构造函数，也容易看到使用的是哪个构造函数。也可以进行适当地参数类型检查。


<code class="section">方法不能重载 </code>

和构造函数同样的原因: 参数类型不总是显而易见的，要判定实际调用的是哪个方法因而
常有困难。最好给方法不同的名字，这样类型检查会如你所愿。这样会排除多态性，但我
们本来就不怎么需要。


<code class="section">单一继承和界面 </code>

一些语言支持多重继承。有些情况这很有用，但类如何工作的规则因而非常复杂。相反
地，使用界面来声明支持何种特性就简单得多。非常流行的 Java 语言就是这么做的，对
Vim 也应该够用了。"尽量简单" 原则在此适用。

显式声明类支持某个界面，会容易看清类的设计用途。这样也可适当地进行类型检查。界
面改变时，也会检查任何声明实现了该界面的类，确定已作了相应的修改。因为类有某界
面的方法就假定它实现了该界面的机制是很脆弱的，会导致微妙的问题，我们不这么做。


<code class="section">在所有地方使用 "this.variable" </code>

不同编程语言中的对象变量有不同的访问方式，取决于出现的位置。有时需要 "this."
前缀避免歧义。通常的声明可以没有 "this."。这很不一致，有时会引起混淆。

一个常见的问题是构造函数里参数名和对象变量名相同。在函数本体里访问这些变量需要
"this." 前缀，而访问其它变量却不需要，常常省略。这造成了带 "this." 的变量和不
带的混用，非常不统一。

 <a href="vim9.html#Vim9">Vim9</a>  类里总是使用 "this." 前缀。包括变量的声明。简单且统一。阅读类内部的代码
时，可以直接看清哪些变量引用指向对象变量，哪些不是。


<code class="section">使用类变量 </code>

使用 "static variable" 来声明类变量很常见，没什么新奇的。 <a href="vim9.html#Vim9">Vim9</a>  脚本里类变量可
通过名字直接访问。就像方法里使用脚本局部变量一样。因为对象变量访问时必须带上
"this." 前缀，是何种变量可快速判断。

TypeScript 在类变量名前加上类名前缀，即使在类内部也是如此。这有两个问题: 类名
可能颇长，会占据相当空间，而且类改名时这些地方也要跟着改名。


<code class="section">声明对象及类变量 </code>

我们面临的主要选择是变量声明是否使用 "var"。
TypeScript 不用: 
<code class="example">        class Point {</code>
<code class="example">          x: number;</code>
<code class="example">          y = 0;</code>
<code class="example">        }</code>
<code class="example"></code>
仿照此风格，Vim 对象变量可以这样声明: 
<code class="example">        class Point</code>
<code class="example">          this.x: number</code>
<code class="example">          this.y = 0</code>
<code class="example">        endclass</code>
<code class="example"></code>
有些用户指出，这看来更像是赋值而不是声明。加上 "var" 改变了这一点: 
<code class="example">        class Point</code>
<code class="example">          var this.x: number</code>
<code class="example">          var this.y = 0</code>
<code class="example">        endclass</code>
<code class="example"></code>
为此，也需要用 "static" 关键字来声明类变量。这时可以选择省略 "var": 
<code class="example">        class Point</code>
<code class="example">          var this.x: number</code>
<code class="example">          static count = 0</code>
<code class="example">        endclass</code>
<code class="example"></code>
用的话，可以放在 "static" 之前: 
<code class="example">        class Point</code>
<code class="example">          var this.x: number</code>
<code class="example">          var static count = 0</code>
<code class="example">        endclass</code>
<code class="example"></code>
也可以放在 "static" 之后: 
<code class="example">        class Point</code>
<code class="example">          var this.x: number</code>
<code class="example">          static var count = 0</code>
<code class="example">        endclass</code>
<code class="example"></code>
这与 "static def Func()" 更一致些。

是否使用 "var" 没有明显优劣。我们不用的两个主要原因是: 
1. TypeScript、Java 和其它流行语言不用。
2. 少点拥挤。


<code class="section">用 "ClassName.new()" 来构造对象 </code>

许多语言使用 "new" 操作符来创建对象，这有点奇怪，因为构造函数定义为带参数的方
法，而不是命令。TypeScript 也有 "new" 关键字，但方法名却是 "constructor()"，很
难看清两者的关联。

 <a href="vim9.html#Vim9">Vim9</a>  脚本里构造方法叫做 new()，也使用 new() 调用，简单直接。其它语言使用
"new ClassName()" 而没有 ClassName() 方法，反而是名为 ClassName 的类里带其它名
字的方法。很混淆。


<code class="section">对象变量缺省读访问 </code>

许多用户评论道对象变量的访问规则不对称。好吧，这是有意的。修改值和读取值是很不
同的操作。读操作没有副作用，可以进行任何次数而不影响对象本身。修改值则可能有很
多副作用，甚至会有连锁反应，影响到其它对象。

新增对象变量时，人们一般想不到这么多，类型对就够了。值通常在 new() 方法里赋
值。所以缺省读访问在绝大多数情况下 "应该就很好"。直接修改时会有报错，提醒你是
不是真地要这么干。写代码时这可以帮助少点错误。


<code class="section">加下划线使对象变量私有 </code>

对象变量私有时，只可在类 (和子类) 中读取和修改，不能在类外使用。前加下划线是这
么做的简单办法。若干编程语言建议如此。

如果要改变想法，使对象变量在类外也可访问，只要在所有的地方删除下划线。因为名字
只出现在类 (和子类) 中，应该容易找到和修改。

反过来就难很多: 可以简单地在对象变量前加上下划线使之私有，但所有其它地方你要自
己追踪到和修改。可能要提供 "set" 方法调用。这也反映了现实中的问题，拿走权限需
要在所有使用该权限的地方下功夫。

替代方案会用 "private" 关键字，就像 "public" 在反方向修改访问那样。好吧，不这
么做只是为了减少关键字数量。


<code class="section">没有保护对象变量 </code>

有些语言提供了若干方法控制对象变量的访问。最有名的是 "protected"，其意义随语言
有所不同。其它的还有 "shared"、"private" 甚至 "friend"。

这些规则使生活变麻烦。在许多人在同一个复杂的代码上操作的项目里，容易出错而这些
规则可能有其合理性。尤其是重整或其它类模型上的修改。

Vim 脚本目标是为了插件设计，编写者只有一个人或小团队。复杂的规则只会让事情更复
杂，规则提供的额外安全性并非必要。我们还是简单点，不要去指定访问的细节了。


</section><hr class="doubleline" /><section class=inner>
<h4></h4>10. 以后再做

newSomething() 构造函数可以调用另一个构造函数吗？如果是的话，有什么限制？

想法:
- 类的泛型: `class &lt;Tkey, Tentry&gt;`
- 函数的泛型: `def <code class="special">&lt;Tkey&gt;</code> GetLast(key: Tkey)`
- 织入: 不确定有没有用，为简单先不列入。

看来是好的新增特性:
- 用于测试: Mock 机制

一种将来会提供的重要的类是 "Promise"。因为 Vim 是单线程的，和异步操作连接是允
许插件实现非用户阻塞式功能的自然方式。这将是调用回调和处理超时以及错误的统一方
法。


 vim:tw=78:ts=8:noet:ft=help:norl:
</section>
</article>
<footer>
Generated by vim2html
</footer>
</body>
</html>
